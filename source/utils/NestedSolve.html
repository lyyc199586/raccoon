<!DOCTYPE html><head><meta charset="UTF-8"><title>NestedSolve | RACCOON</title><link rel="icon" type="image/x-icon" href="../../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="7febc833-fe22-43a7-a929-0fee78409fb9" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="f0c96ce5-ebff-4302-a928-f25953a19a14" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="477c1bfd-f1f2-49e4-8261-70a436db6e89" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="8ceb342c-4266-4fdb-baaa-c71c7591938c" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="3dcc142f-615f-4f36-a89d-afa7b8f44ec9"><i class="material-icons">menu</i></a><ul class="sidenav" id="3dcc142f-615f-4f36-a89d-afa7b8f44ec9"><li><a href="#!" class="dropdown-trigger" data-target="284790f9-7e30-45f5-b44c-dc50d72be36a" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="c5945956-388e-4391-8e46-7a272300e288" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b71adf75-4656-474f-a17f-15a11131439d" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="63a1130d-f09d-450e-82bb-96772d748eb5" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="7febc833-fe22-43a7-a929-0fee78409fb9"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li></ul><ul class="dropdown-content" id="f0c96ce5-ebff-4302-a928-f25953a19a14"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li></ul><ul class="dropdown-content" id="477c1bfd-f1f2-49e4-8261-70a436db6e89"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="8ceb342c-4266-4fdb-baaa-c71c7591938c"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/tensor_mechanics.html">Tensor mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_conduction.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="284790f9-7e30-45f5-b44c-dc50d72be36a"><li><a href="../../getting_started/install.html">Install RACCOON</a></li><li><a href="../../getting_started/update.html">Update RACCOON</a></li><li><a href="../../getting_started/running.html">Running your first model</a></li><li><a href="../../getting_started/paraview.html">Visualization</a></li><li><a href="../../getting_started/ide.html">Code development</a></li></ul><ul class="dropdown-content" id="c5945956-388e-4391-8e46-7a272300e288"><li><a href="../../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li></ul><ul class="dropdown-content" id="b71adf75-4656-474f-a17f-15a11131439d"><li><a href="../../theory/intro.html">Introduction</a></li><li><a href="../../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../../theory/minimization.html">The minimization problem</a></li><li><a href="../../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="63a1130d-f09d-450e-82bb-96772d748eb5"><li><a href="../../modules/index.html">Physics modules</a></li><li><a href="../../syntax/index.html">Complete syntax</a></li><li><a href="../../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../../syntax/tensor_mechanics.html">Tensor mechanics syntax</a></li><li><a href="../../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../../syntax/heat_conduction.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="7ed8fc9d-199f-47c6-ade8-d44a46b847ad" data-section-level="1" data-section-text="NestedSolve"><h1 id="nestedsolve">NestedSolve</h1><section id="8472daba-c9f9-44e2-a8b7-3dbc9f61a8bc" data-section-level="2" data-section-text="Overview"><h2 id="overview">Overview</h2><p>The <code>NestedSolve</code> utility class implements a non-linear solve for NxN systems. It can be used in Kernels, Materials, and UserObjects to compute quantities given by the solution of a non-linear equation system rather than a closed form expression.</p><p>Such a non-linear equation system is defined by a residual function and a Jacobian function. These functions are provided as C++11 lambda expression. A lambda expression can access all local and member variables from the enclosing scope. In this application that mainly refers to coupled variable values and material properties available in the class the NestedSolve is utilized.</p><section id="a5099abd-5812-4d6f-893e-a53722423b64" data-section-level="3" data-section-text="Basic API"><h3 id="basic-api">Basic API</h3><p><code>NestedSolve</code> is a C++ class object needs to be instantiated (constructed) to set up a solver environment. This solver environment can be a local or member variable of the object it is used within.</p><p>The purpose of the solve environment is to store <em>solver options</em>, such as tolerances, and <em>solver state</em>, such as convergence reason or failure state of the previous solve. A solve environment can be reused for multiple solves.</p><p>The main API of <code>NestedSolve</code> is the <code>nonlinear</code> member function, which exists in two flavors:</p><ol class="browser-default" start="1"><li><p><code>NestedSolve::nonlinear(T &amp; guess, L compute)</code>, which takes a writable reference to a variable if type <code>T</code> that contains an initial guess for the solution going into the function, and the solution once the call completes. <code>compute</code> is a lambda expression that takes references to the current solution value, the residual, and the Jacobian, and needs to update the latter two. </p></li><li><p><code>NestedSolve::nonlinear(T &amp; guess, LR computeResidual, LJ computeJacobian)</code> behaves largely similar to the first overload, but it takes two separate lambdas for computing the residual and the Jacobian independently. This enables the efficient use of line search and trust region algorithms internally.</p></li></ol></section><section id="79029be7-731c-49be-874e-3a1a27c1a368" data-section-level="3" data-section-text="Supported data types"><h3 id="supported-data-types">Supported data types</h3><p>The recommended data types for the solution/residual (<code>T</code>) and Jacobian are Eigen&#x27;s dynamic size Matrix objects. the <code>NestedSolve::Value&lt;&gt;</code> and <code>NestedSolve::Jacobian&lt;&gt;</code> typedefs are available as shortcuts for those types.</p><p>Specializations and overloads exist for the <code>nonlinear</code> solve API to deal with the special cases of 1x1 systems (with the solution,residual, and Jacobians being <code>Real</code> scalars), and for 3x3 systems (with the solution and residual bein <code>RealVectorValues</code> and Jacobians being <code>RankTwoTensor</code> values). The correct overload is picked based on the type <code>T</code> of the initial <code>guess</code> parameter.</p></section></section><section id="f0b99217-4a7b-4601-a04c-8e1469bd546d" data-section-level="2" data-section-text="Example"><h2 id="example">Example</h2><section id="d7214403-31cf-4ce2-ab90-7b74c471f7d4" data-section-level="3" data-section-text="Basic usage"><h3 id="basic-usage">Basic usage</h3><p>We first construct a <code>NestedSolve</code> object. This object can be reused for multiple solves, and could be a member of the class you are using it in.</p><pre class="moose-pre"><code class="language-text">
NestedSolve solver;
</code></pre><p>Next we set the solution (vector) type. <code>NestedSolve::Value&lt;&gt;</code> is a dynamicly sized vector class from the Eigen library. Eigen uses the <code>&lt;&lt;</code> operator to initialize such a vector (two components in this case).</p><pre class="moose-pre"><code class="language-text">
NestedSolve::Value&lt;&gt; solution(2);
solution &lt;&lt; 1.98, 1.02;
</code></pre><p>Next we set a custom relative tolerance. The default value here is 1e-8.</p><pre class="moose-pre"><code class="language-text">
solver.setRelativeTolerance(1e-10);
</code></pre><p>Next we define the residual and Jacobian functions. Here we use a single lambda with three arguments:</p><ol class="browser-default" start="1"><li><p>The first argument is the current guess for the solution and is the _input_ to the functions, it is a vector of length N (or a scalar). </p></li><li><p>Argument two is a writable reference to the residual vector (of the same size as the current guess), the value of which is to be calculated by the lambda. </p></li><li><p>This is followed by the Jacobian matrix of the system, the derivative of the resdual vector with respect to the guess/solution.</p></li></ol><pre class="moose-pre"><code class="language-text">
auto compute = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                   NestedSolve::Value&lt;&gt; &amp; residual,
                   NestedSolve::Jacobian&lt;&gt; &amp; jacobian) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;

  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
</code></pre><p>Note that <code>jacobian(i,j)</code> is the derivative of <code>residual(i)</code> with respect to <code>guess(j)</code>.</p><p>Lastly we pass the initial guess along with the residual/Jacobian <code>compute</code> lambda to the <code>NestedSolve::nonlinear</code> method.</p><pre class="moose-pre"><code class="language-text">
solver.nonlinear(solution, compute);
</code></pre><p><code>solution</code> will now be updated from the initial guess to the actual solution of the system.</p></section><section id="cbf49924-7a9f-4a49-9c78-742be92f672d" data-section-level="3" data-section-text="Powell ' s Dogleg method solver"><h3 id="powell-s-dogleg-method-solver">Powell&#x27;s Dogleg method solver</h3><p>While the previous example used a single lambda to compute residual and Jacobian at the same time, we can instead change the code to have sparate lambdas to allow independent calculation of residual and Jacobian. This facilitates the use of solver methods that evaluate the residual more frequantly than the Jacobian, such as line search and trust region strategies.</p><pre class="moose-pre"><code class="language-text">
auto computeResidual = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                           NestedSolve::Value&lt;&gt; &amp; residual) {
  residual(0) = guess(0) + guess(0) * guess(1) - 4;
  residual(1) = guess(0) + guess(1) - 3;
};

auto computeJacobian = [&amp;](const NestedSolve::Value&lt;&gt; &amp; guess,
                           NestedSolve::Jacobian&lt;&gt; &amp; jacobian) {
  jacobian(0, 0) = 1 + guess(1);
  jacobian(0, 1) = guess(0);
  jacobian(1, 0) = 1;
  jacobian(1, 1) = 1;
};
</code></pre><p>We then use the three argument version of the <code>nonlinear</code> method</p><pre class="moose-pre"><code class="language-text">
solver.nonlinear(solution, computeResidual, computeJacobian);
</code></pre></section></section></section></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>