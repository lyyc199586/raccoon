<!DOCTYPE html><head><meta charset="UTF-8"><title>What is a Requirement | RACCOON</title><link rel="icon" type="image/x-icon" href="../media/raccoon_icon.png" sizes="16x16 32x32 64x64 128x128"></link><link href="../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../css/civet_moose.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../contrib/jquery/jquery.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../index.html" class="left moose-logo hide-on-med-and-down">RACCOON</a><a href="https://github.com/hugary1995/raccoon" class="right"><img src="../media/framework/github-logo.png" class="github-mark"></img><img src="../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="3a3d56fa-322a-49af-88ac-2d4243f3e41c" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="599e7618-45ef-4e20-9df6-8261a1727a8b" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="476bbe07-248c-48ef-a597-f5f0600d9060" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="17c876db-8c8a-4171-9a3b-e5bc46d9a710" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../contribute/index.html">Contribute</a></li></ul><a href="#" class="sidenav-trigger" data-target="58e5b746-f0c9-47e1-8f0c-e09e9995905f"><i class="material-icons">menu</i></a><ul class="sidenav" id="58e5b746-f0c9-47e1-8f0c-e09e9995905f"><li><a href="#!" class="dropdown-trigger" data-target="346d3909-7597-43c3-a0fe-a587ee9602e1" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="ec02345d-c52e-4c6d-a35e-9d6a010947a1" data-constrainWidth="false">Tutorials<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="d6c02026-cd19-4c83-af9a-b12c69b62757" data-constrainWidth="false">Theory<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="a3ceae74-333a-4e20-ae5d-3c50897cd63b" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../contribute/index.html">Contribute</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="3a3d56fa-322a-49af-88ac-2d4243f3e41c"><li><a href="../getting_started/install.html">Install RACCOON</a></li><li><a href="../getting_started/update.html">Update RACCOON</a></li><li><a href="../getting_started/running.html">Running your first model</a></li><li><a href="../getting_started/paraview.html">Visualization</a></li><li><a href="../getting_started/ide.html">Code development</a></li></ul><ul class="dropdown-content" id="599e7618-45ef-4e20-9df6-8261a1727a8b"><li><a href="../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li></ul><ul class="dropdown-content" id="476bbe07-248c-48ef-a597-f5f0600d9060"><li><a href="../theory/intro.html">Introduction</a></li><li><a href="../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../theory/minimization.html">The minimization problem</a></li><li><a href="../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="17c876db-8c8a-4171-9a3b-e5bc46d9a710"><li><a href="../modules/index.html">Physics modules</a></li><li><a href="../syntax/index.html">Complete syntax</a></li><li><a href="../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../syntax/tensor_mechanics.html">Tensor mechanics syntax</a></li><li><a href="../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../syntax/heat_conduction.html">Heat conduction syntax</a></li></ul><ul class="dropdown-content" id="346d3909-7597-43c3-a0fe-a587ee9602e1"><li><a href="../getting_started/install.html">Install RACCOON</a></li><li><a href="../getting_started/update.html">Update RACCOON</a></li><li><a href="../getting_started/running.html">Running your first model</a></li><li><a href="../getting_started/paraview.html">Visualization</a></li><li><a href="../getting_started/ide.html">Code development</a></li></ul><ul class="dropdown-content" id="ec02345d-c52e-4c6d-a35e-9d6a010947a1"><li><a href="../tutorials/01_small_deformation_elasticity.html">1. Small deformation</a></li><li><a href="../tutorials/02_mode1_brittle_fracture.html">2. Mode-I fracture</a></li><li><a href="../tutorials/03_mode2_brittle_fracture.html">3. Mode-II fracture</a></li><li><a href="../tutorials/04_fiber_reinforced_matrix.html">4. Fiber-reinforced matrix</a></li><li><a href="../tutorials/05_soil_desiccation.html">5. Soil desiccation</a></li><li><a href="../tutorials/06_large_deformation_elasticity.html">6. Large deformation</a></li><li><a href="../tutorials/07_elastoplasticity.html">7. Elastoplasticity</a></li><li><a href="../tutorials/08_ductile_fracture.html">8. Ductile fracture</a></li><li><a href="../tutorials/09_three_point_bending.html">9. Three-point bending</a></li><li><a href="../tutorials/10_quenching_bibeam.html">10. Quenching of bi-beam</a></li><li><a href="../tutorials/11_adaptivity.html">11. Adaptive mesh refinement</a></li></ul><ul class="dropdown-content" id="d6c02026-cd19-4c83-af9a-b12c69b62757"><li><a href="../theory/intro.html">Introduction</a></li><li><a href="../theory/kinematics.html">State variables and kinematics</a></li><li><a href="../theory/thermodynamics.html">Thermodynamics</a></li><li><a href="../theory/minimization.html">The minimization problem</a></li><li><a href="../theory/constitutive_models.html">Constitutive Models</a></li></ul><ul class="dropdown-content" id="a3ceae74-333a-4e20-ae5d-3c50897cd63b"><li><a href="../modules/index.html">Physics modules</a></li><li><a href="../syntax/index.html">Complete syntax</a></li><li><a href="../syntax/raccoon.html">RACCOON syntax</a></li><li><a href="../syntax/tensor_mechanics.html">Tensor mechanics syntax</a></li><li><a href="../syntax/phase_field.html">Phase field syntax</a></li><li><a href="../syntax/heat_conduction.html">Heat conduction syntax</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="moose-content col s12 m12 l12"><section id="29951b3e-3678-42ac-8f03-831ead734c0f" data-section-level="1" data-section-text="What is a Requirement ?"><h1 id="what-is-a-requirement">What is a Requirement?</h1><p>The &quot;Software Requirement Specification (SRS)&quot; is created from a set of &quot;requirements&quot; that must be: correct, complete, consistent, unambiquous, ranked, verifiable, modifiable, and traceable (<a href="#ieee1998recommended">IEEE, 1998</a>).</p><p>Within MOOSE the decision was made that each test is a requirement. This relationship is not dictated by any standard, it was a decision that was made to allow for the above characteristics to be satisfied in a maintainable manner. The following sections detail each of these characteristics with respect to implementation within MOOSE.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i>Writing a Requirement</div><div class="card-content"><div class="moose-alert-content"><p><p>Practically, when creating requirement text only one of the aforementioned characteristics really must be considered: <strong>unambiguous</strong>. The other characteristics are generally satisfied automatically, by design, by the nature of the testing and documentation system implementation.</p><p>When writing a requirement, simply ask the question: &quot;<strong>Is the requirement unambiguous?</strong>&quot; Each test was created for a specific reason, the requirement text should reflect this fact. Use this as a means to communicate what the test is testing, i.e., what is the software required to perform to satisfy the test.</p><p>Note that the requirement should be fairly concise, generally no longer than a sentence. If the requirement is longer than a sentence, consider transferring some of the content into the accompanying <code>design</code> markdown file. </p></p></div></div></div><section id="567cac3e-1c9b-4715-8979-ce71401f8b5a" data-section-level="2" data-section-text="Correct"><h2 id="correct">Correct</h2><blockquote><p>An SRS is correct if, and only if, every requirement stated therein is one that the software shall meet (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>The definition of the SRS being &quot;correct&quot; necessitates that each requirement be satisfied, a one-to-one relationship between a test and a requirement makes verify the correctness a trivial operation that may be automated. Within MOOSE all tests must pass, thus all requirements are met, for the code to be merged into the stable (master) branch.</p></section><section id="ff35cdae-79cc-48a6-ad48-13d3de7a88ca" data-section-level="2" data-section-text="Complete"><h2 id="complete">Complete</h2><blockquote><p>An SRS is complete if all requirements are acknowledged and treated, responses of the software to all realizable classes of input (both invalid and valid) exist, and references to all figures, tables, and diagrams in the SRS are valid (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>Each requirement is clearly defined within the test specification allowing for the list of requirements to be automatically generated, therefore all requirements are guaranteed to be acknowledged.</p><p>Tests are created specifically to quantify and verify the response of the software to inputs, both valid and invalid. The word &quot;realizable&quot; is important as it is not practical to test all inputs since the number of inputs is infinite. Any shortcoming to this end indicates a lack of sufficient testing, when the testing is complete the SRS is complete.</p><p>The MooseDocs system itself guarantees that all references to tables, figures, and diagrams are valid, if they are not testing fails until these references are defined.</p></section><section id="ad937ae2-9fb8-4849-87bb-4bba023803fb" data-section-level="2" data-section-text="Consistent"><h2 id="consistent">Consistent</h2><blockquote><p>If an SRS does not agree with some higher-level document, it is not correct (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>The SRS and all associated documents that reference a requirement within MOOSE are automatically generated within the MooseDocs system. The system maintains the interconnection of these documents, if they are not in agreement an error is generated prior to the document being merged and released into the stable (master) branch.</p></section><section id="8dfc43ce-e95a-435f-bd4e-a15af370e256" data-section-level="2" data-section-text="Unambiguous"><h2 id="unambiguous">Unambiguous</h2><blockquote><p>An SRS is unambiguous if every requirement stated therein has only one interpretation (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>This characteristic, along with being &quot;verifiable&quot;, is the driving factor for creating a one-to-one connection between a test and a requirement. Each test is created for a specific reason and tests very specific features within the software; the associated requirement then becomes unambiguous by nature of a well-designed test. The requirement also serves as documentation for the test, which is useful in general outside of the SRS.</p></section><section id="8cf3e930-a208-4751-9d3f-a1ac496f6a8c" data-section-level="2" data-section-text="Ranked"><h2 id="ranked">Ranked</h2><blockquote><p>An SRS is ranked for importance if each requirement in it has an identifier to indicate the importance of stability of that particular requirement (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>Within MOOSE tests/requirements are not ranked for importance. As stated above an SRS must be &quot;correct&quot;, which necessitates that all requirements are met. Therefore, ranking is irrelevant.</p></section><section id="3400b9b3-99e2-403a-b889-d12505820f46" data-section-level="2" data-section-text="Verifiable"><h2 id="verifiable">Verifiable</h2><blockquote><p>An SRS is verifiable if there exists some process with which a person or a machine can check that the software product meets the requirement (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>This characteristic of an SRS is a driving factor behind the one-to-one relationship between a requirement and a test. With such a connection the SRS is verifiable by a machine simply by having all the tests passing.</p></section><section id="4e18bc88-9ecd-4a0c-a0b8-540804a5906d" data-section-level="2" data-section-text="Modifiable"><h2 id="modifiable">Modifiable</h2><blockquote><p>An SRS is modifiable if changes to the requirements can be made easily, completely, and consistently while retaining the structure and style (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>Embedding the requirements within the test specifications treats the text for the requirement as code. Coupled with the automatic creating of documents using MooseDocs all changes to requirements are automatically retain proper styling; and, changing them is natural and easy for developers because the changes are made along with traditional source code additions, deletions, and alterations.</p></section><section id="1c336c7f-ad1c-471b-a44b-44438eb9632b" data-section-level="2" data-section-text="Traceable"><h2 id="traceable">Traceable</h2><blockquote><p>An SRS is traceable if the origin of its requirements is clear and if it facilitates the referencing of each requirement in future development or enhancement documentation (<a href="#ieee1998recommended">IEEE, 1998</a>).</p></blockquote><p>Each requirement is embedded in the code repository, which for the case of MOOSE, is a git repository. Then by its very nature of being treated as code the complete history each requirement is tracked at all times.</p></section><section id="e7fb7aba-7722-4918-8d35-61f58494c423" data-section-level="2" data-section-text="References"><h2 id="references">References</h2><div class="moose-bibliography"><ol><li id="ieee1998recommended">IEEE.
Recommended practice for software requirements specifications.
<em>Standard 830-1998</em>, pages 1&ndash;40, Oct 1998.
<a href="https://doi.org/10.1109/IEEESTD.1998.88286">doi:10.1109/IEEESTD.1998.88286</a>.<a href="#5b227eff-4fa8-4e41-a844-4d8f15fbeb60" class="modal-trigger moose-bibtex-modal" style="padding-left:10px;">[BibTeX]</a><div class="modal" id="5b227eff-4fa8-4e41-a844-4d8f15fbeb60"><div class="modal-content"><pre style="line-height:1.25;"><code class="language-latex">@article{ieee1998recommended,
    author = "IEEE",
    journal = "Standard 830-1998",
    title = "Recommended Practice for Software Requirements Specifications",
    year = "1998",
    pages = "1-40",
    doi = "10.1109/IEEESTD.1998.88286",
    month = "Oct"
}
</code></pre></div></div></li></ol></div></section></section></div></div></div></main></div></body><script type="text/javascript" src="../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../js/init.js"></script><script type="text/javascript" src="../js/navigation.js"></script><script type="text/javascript" src="../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../js/search_index.js"></script><script type="text/javascript" src="../js/sqa_moose.js"></script>